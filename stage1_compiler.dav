// File: compiler.dav
// Author: David T.
// Description: Stage 1 compiler for the dav language.
// This file is compiled by the Stage 0 Python compiler.


// =============================================================
// Global Storage
// =============================================================

// --- Tokenizer Storage ---
beg char* token_types[50000];
beg int token_values[50000]; // Stores index into token_pool, or -1
beg int token_lines[50000];
beg int token_cols[50000];
beg char token_pool[500000]; // String pool for token values
beg int n_tokens = 0;      // Total number of tokens found

// --- Parser State ---
beg int parser_pos = 0; // Current token index for the parser
beg char* current_fn_ret_type; // Stores return type of fn being parsed
beg char* expr_type;    // Type of the last parsed expression, works like a forgetful stack

// --- Symbol Table Storage ---
// We store 'char*' pointers for names and types.
// The Stage 0 compiler will get the name strings from the token_pool.
// The type strings will be string literals (e.g., "int", "char*").

// Global Scope (self.env)
beg char* global_names[1000];
beg char* global_types[1000];
beg int n_globals = 0;

// Local Scope (self.variables)
beg char* local_names[1000];
beg char* local_types[1000];
beg int n_locals = 0;

// --- C Code Generation Buffer ---
beg char c_code_buffer[1000000]; // 1MB buffer for generated C
beg int c_code_pos = 0;         // Current position in the buffer

// --- Peek Buffer ---
beg char expr_peek_buffer[4096]; // Scratchpad for peeking code


// =============================================================
// Function Declarations
// =============================================================

// --- Lexer Helpers ---
ah int is_letter(char c);
ah int is_digit(char c);
ah int is_space(char c);
ah int is_ident_char(char c);
ah char* check_keywords(char* s);
ah int add_simple_token(int index, char* type, int line, int col);

ah int tokenize(char* source_code);

// --- Parser Helpers ---
ah int parse();
ah int global_decl();
ah int fn_decl();
ah int statement();
ah int let_stmt(int is_global);
ah int print_stmt();
ah int if_stmt();
ah int while_stmt();
ah int return_stmt();
ah int id_stmt();

ah int expr();
ah int logical();
ah int relational();
ah int additive();
ah int multiplicative();
ah int unary();
ah int atom();

ah char* peek();
ah int next();
ah int expect(char* kind);

ah int clear_local_symbols();
ah char* get_symbol_type(int is_global, char* name);
ah int add_symbol(int is_global, char* name, char* type);

ah int str_ends_with(char* s, char c);
ah char* op_to_c_op(char* tok_type);
ah int emit(char* s);
ah char* peek_code(char* level);
ah int c_include();
ah int c_prototype();
ah int c_helper();
ah int preset_global_functions();


// =============================================================
// Main Entry Point
// =============================================================

ah int main(int argc, char* argv[]) {
    if argc != 3 {
        boo("Usage: compiler <input_file.dav> <output_file.c>");
        return 1;
    }

    beg char* input_file = argv[1];
    beg char* output_file = argv[2];

    // 1. Read Input File
    beg char* code = read_file(input_file);
    
    if code == 0 { // NULL check
        boo("Error: Could not read input file.");
        return 1;
    }

    // 2. Setup Code Generation
    c_include();
    c_prototype();
    preset_global_functions();
    
    // 3. Tokenize
    n_tokens = tokenize(code);

    // 4. Parse
    parse();

    // 5. Emit Helpers
    c_helper();
    
    // 6. Write Output File
    write_file(output_file, c_code_buffer);
    
    // boo("Done.");
    return 0;
}


// =============================================================
// Parser
// =============================================================

ah int parse() {
    // Main parser entry point.
    // Loops until EOF, parsing all global declarations.

    while peek() != "EOF" {
        global_decl();
    }
    return 0;
}

ah int global_decl() {
    // Dispatches to the correct parser function
    // based on the next token.
    beg char* tok = peek();

    if tok == "FN" {
        fn_decl();
    } else if tok == "LET" {
        let_stmt(1); // 1 for global
    } else {
        // Error handling
        beg int tok_line = token_lines[parser_pos];
        boo("Error: Unexpected global token on line " + itos(tok_line));
        boo("Expected FN, LET, or COMMENT, but got: " + tok);
        
        // Consume the bad token to prevent infinite loop
        next(); 
        return -1;
    }
    return 0;
}

ah int fn_decl() {
    // Parses a function declaration or definition
    beg int fn_tok_idx = expect("FN");
    beg int line_num = token_lines[fn_tok_idx];
    
    // --- Get Type ---
    beg char* fn_type = "void"; // Default type
    if peek() == "TYPE" {
        beg int fn_type_idx = next();
        fn_type = token_pool + token_values[fn_type_idx];
    }

    // --- Get Pointer ---
    if peek() == "MUL" {
        next();
        if fn_type == "int" { fn_type = "int*"; }
        else if fn_type == "char" { fn_type = "char*"; }
        else if fn_type == "char*" { fn_type = "char**"; }
        else { boo("Error: Cannot make array of type " + fn_type); return -1; }
    }

    // --- Get Name ---
    beg int fn_name_idx = expect("ID");
    beg char* fn_name = token_pool + token_values[fn_name_idx];

    // --- Store for type-checking 'return' ---
    current_fn_ret_type = fn_type;
    add_symbol(1, fn_name, fn_type);

    expect("LPAREN");

    emit(fn_type); emit(" "); emit(fn_name); emit("(");

    // --- Parse parameters ---
    // Parallel arrays to store parameters
    beg char* param_types[20];
    beg char* param_names[20];
    beg int param_has_arrays_part[20];
    beg int n_params = 0;
    beg int i = 0;

    while peek() != "RPAREN" {
        if n_params > 0 {
            expect("COMMA");
            emit(", ");
        }

        // Get param type (default int)
        beg char* param_type = "int";
        if peek() == "TYPE" {
            beg int param_type_idx = next();
            param_type = token_pool + token_values[param_type_idx];
        }


        // Get param pointer
        if peek() == "MUL" {
            next();
            if param_type == "int" { param_type = "int*"; }
            else if param_type == "char" { param_type = "char*"; }
            else if param_type == "char*" { param_type = "char**"; }
            else { boo("Error: Cannot make array of type " + param_type); return -1; }
        }

        // Get param name
        beg int param_name_idx = expect("ID");
        beg char* param_name = token_pool + token_values[param_name_idx];

        emit(param_type); emit(" "); emit(param_name);

        // Check for array param part
        beg int param_array_part = 0;
        if peek() == "LSQUARE" {
            next();
            param_array_part = 1;
            if peek() == "NUMBER" {
                beg int size_idx = next();
                beg char* size_str = token_pool + token_values[size_idx];
                emit("["); emit(size_str); emit("]");
            } else {
                emit("[]");
            }
            expect("RSQUARE");
        }

        // Store param
        param_types[n_params] = param_type;
        param_names[n_params] = param_name;
        param_has_arrays_part[n_params] = param_array_part;
        n_params = n_params + 1;
    }
    expect("RPAREN");
    emit(")");

    // --- Check for Prototype (;) or Definition ({) ---
    if peek() == "SEMICOL" {
        // Function Declaration (Prototype)
        next();
        emit(";\n");
        return 0;
    }
    else if peek() == "LBRACE" {
        // Function Definition
        next();
        emit(" {\n");
        
        // --- Setup local scope ---
        clear_local_symbols();
        i = 0;
        while i < n_params {
            beg char* var_type = param_types[i];
            if param_has_arrays_part[i] == 1 {
                if var_type == "int" { var_type = "int*"; }
                else if var_type == "char" { var_type = "char*"; }
                else if var_type == "char*" { var_type = "char**"; }
                else { boo("Error: Cannot make array of type " + var_type); }
            }
            add_symbol(0, param_names[i], var_type);
            i = i + 1;
        }
        
        // --- Parse function body ---
        while peek() != "RBRACE" && peek() != "EOF" {
            statement();
        }
        expect("RBRACE");
        
        emit("}\n");
        return 0;
    }
    else {
        boo("Error: Expected ';' or '{' after function signature, line " + itos(line_num));
        return -1;
    }
}

ah int statement() {
    // Dispatches to the correct statement parser.
    beg char* tok = peek();
    
    if tok == "LET" {
        let_stmt(0); // 0 for local
    } else if tok == "PRINT" {
        print_stmt();
    } else if tok == "IF" {
        if_stmt();
    } else if tok == "WHILE" {
        while_stmt();
    } else if tok == "RETURN" {
        return_stmt();
    } else if tok == "ID" {
        id_stmt();
    } else {
        boo("Error: Unexpected statement: " + tok + " on line " + itos(token_lines[parser_pos]));
        next(); // Consume bad token
        return -1;
    }
    return 0;
}

ah int let_stmt(int is_global) {
    beg int line_num = token_lines[parser_pos];
    expect("LET");

    // --- Get Type ---
    beg char* var_type = "undefined"; // Unspecified type
    if peek() == "TYPE" {
        beg int var_type_idx = next();
        var_type = token_pool + token_values[var_type_idx];
    }

    // --- Get Pointer ---
    if peek() == "MUL" {
        next();
        if var_type == "int" { var_type = "int*"; }
        else if var_type == "char" { var_type = "char*"; }
        else { boo("Error: Cannot make array of type " + var_type); return -1; }
    }

    // --- Get Name ---
    beg int var_name_idx = expect("ID");
    beg char* var_name = token_pool + token_values[var_name_idx];

    // Check redefinition
    if (is_global == 0 && get_symbol_type(0, var_name) != "") ||
       (is_global == 1 && get_symbol_type(1, var_name) != "") {
        
        boo("Error: Redefinition of variable" + var_name + ", line " + itos(line_num));
        return -1; // Error
    }

    // --- Parsing Cases ---
    if peek() == "ASSIGN" {
        // --- Case 1: Declaration with Assignment (e.g., beg x = 10) ---
        next();

        emit(var_type); emit(" "); emit(var_name); emit(" = ");
        expr(); // This emits the C code for the RHS
        emit(";\n");

        beg char* right_type = expr_type;
        
        // TODO: inference not working, come back to fix me please

        if var_type == "undefined" {
            var_type = right_type; // Infer type
        } else if var_type != right_type {
            boo("Error: Incompatible type " + right_type + " to " + var_type + ", line " + itos(line_num));
            return -1;
        }
        
        expect("SEMICOL");
        add_symbol(is_global, var_name, var_type);
        return 0;
    }
    else if peek() == "LSQUARE" {
        // --- Case 2: Array Declaration (e.g., beg int arr[10]) ---
        next();

        if var_type == "undefined" {
            boo("Error: Array declaration must have an explicit type on line" + itos(line_num));
            return -1;
        }
        
        beg int size_tok = expect("NUMBER");
        beg char* size = token_pool + token_values[size_tok];
        
        expect("RSQUARE");
        expect("SEMICOL");

        // Store array type as 'base_type*' (e.g., 'int*')
        beg char* array_type = "int*"; // Default
        if var_type == "int" { array_type = "int*"; }
        else if var_type == "char" { array_type = "char*"; }
        else if var_type == "char*" { array_type = "char**"; }
        else { boo("Error: Cannot make array of type " + var_type); return -1; }
        add_symbol(is_global, var_name, array_type);
        
        // C code: e.g., "int arr[10];"
        emit(var_type); emit(" "); emit(var_name); emit("["); emit(size); emit("];\n");
        return 0;
    }
    else if peek() == "SEMICOL" {
        // --- Case 3: Declaration without Assignment (e.g., beg int x;) ---
        next();
        
        if var_type == "undefined" {
            boo("Error: Declaration without assignment must have explicit type on line" + itos(line_num));
            return -1;
        }
        
        add_symbol(is_global, var_name, var_type);
        emit(var_type); emit(" "); emit(var_name); emit(";\n");
        return 0;
    }
    else {
        boo("Error: Expected '=', '[', or ';' after variable name on line" + itos(line_num));
        next(); // Consume bad token
        return -1;
    }
}

ah int print_stmt() {
    beg int line_num = token_lines[parser_pos];
    expect("PRINT");
    expect("LPAREN");
    
    // Peek the code for the expression to determine its type
    // Level "expr" calls the top-level expr() parser
    beg char* expr_code = peek_code("expr");
    beg char* type = expr_type; // peek_code sets this global

    if (type == "int") {
        emit("printf(\"%d\\n\", ");
    } else if (type == "char") {
        emit("printf(\"%c\\n\", ");
    } else if (type == "char*") {
        emit("printf(\"%s\\n\", ");
    } else {
        boo("Error: Unprintable type '" + type + "' on line " + itos(line_num));
        return -1;
    }
    
    // Now emit the code we peeked
    emit(expr_code);
    emit(");\n");
    
    expect("RPAREN");
    expect("SEMICOL");
    return 0;
}

ah int id_stmt() {
    // Handles statements beginning with an identifier:
    // 1. x = 10;        (Assignment)
    // 2. my_func(10);   (Function Call)
    // 3. arr[0] = 5;    (Array Assignment)

    beg int tok_idx = next();
    beg int line_num = token_lines[tok_idx];
    beg char* var_name = token_pool + token_values[tok_idx];

    // Get variable from local/global scope
    beg char* var_type = get_symbol_type(0, var_name);

    // Declare this here since this compiler can't handle
    // sub-function (if/while body) scoped declarations
    beg char* right_type;

    if var_type == "" {
        boo("Error: Undeclared identifier '" + var_name + "' on line " + itos(line_num));
        return -1;
    }
    
    // --- Case 1: Variable Assignment ---
    if peek() == "ASSIGN" {
        next();
        
        emit(var_name); emit(" = ");
        expr(); // Emits RHS
        emit(";\n");
        
        // Type check
        beg char* right_type = expr_type;
        if var_type != right_type {
            boo("Error: Incompatible " + right_type + " to " + var_type + " conversion on line " + itos(line_num));
            return -1;
        }
        expect("SEMICOL");
        return 0;
    }

    // --- Case 2: Function Call ---
    else if peek() == "LPAREN" {
        next();

        // TODO: Check if var_type is a function type
        // For now, we assume if it's not an assignment, it's a function call.

        emit(var_name); emit("(");

        beg int arg_count = 0;
        while peek() != "RPAREN" {
            if arg_count > 0 {
                expect("COMMA");
                emit(", ");
            }
            expr(); // Emits argument
            arg_count = arg_count + 1;
        }
        expect("RPAREN");
        expect("SEMICOL");

        emit(");\n");
        return 0;
    }

    // --- Case 3: Array Assignment ---
    else if peek() == "LSQUARE" {
        next();

        // Check if var_type is a pointer
        if str_ends_with(var_type, '*') == 0 {
            boo("Error: Variable '" + var_name + "' is not an array and cannot be indexed, line " + itos(line_num));
            return -1;
        }

        emit(var_name); emit("[");
        expr(); // Emits index
        emit("] = ");

        if expr_type != "int" {
            boo("Error: Array index must be an integer, got " + expr_type + ", line " + itos(line_num));
            return -1;
        }

        expect("RSQUARE");
        expect("ASSIGN");

        expr(); // Emits RHS
        emit(";\n");

        // Type check
        right_type = expr_type;
        beg char* base_type = "int"; // Default to int
        if var_type == "int*" { base_type = "int"; }
        else if var_type == "char*" { base_type = "char"; }

        if base_type != right_type {
            boo("Error: Incompatible types: cannot assign " + right_type + " to array element of type " + base_type + ", line " + itos(line_num));
            return -1;
        }

        expect("SEMICOL");
        return 0;
    }

    // --- Case 4: Error ---
    else {
        boo("Error: Invalid statement start. Expected '=', '(', or '[' after ID '" + var_name + "', line " + itos(line_num));
        return -1;
    }
}

ah int if_stmt() {
    expect("IF");

    emit("if (");
    expr(); // Emit condition
    emit(") {\n");

    expect("LBRACE");
    while peek() != "RBRACE" && peek() != "EOF" {
        statement();
    }
    expect("RBRACE");
    emit("}\n");

    // Handle else
    if peek() == "ELSE" {
        next();
        emit("else ");

        // Case 1: else-if
        if peek() == "IF" {
            if_stmt();
        }
        
        // Case 2: else
        else if peek() == "LBRACE" {
            next();
            emit("{\n");
            while peek() != "RBRACE" && peek() != "EOF" {
                statement();
            }
            expect("RBRACE");
            emit("}\n");
        }

        // Case 3: Error
        else {
            beg int tok_line = token_lines[parser_pos];
            boo("Error: Expected 'if' or '{' after 'else', line " + itos(tok_line));
            return -1;
        }
    }
    return 0;
}

ah int while_stmt() {
    expect("WHILE");

    emit("while (");
    expr();
    emit(") {\n");
    
    expect("LBRACE");
    while peek() != "RBRACE" && peek() != "EOF" {
        statement();
    }
    expect("RBRACE");
    emit("}\n");
    return 0;
}

ah int return_stmt() {
    beg int line_num = token_lines[parser_pos];
    expect("RETURN");

    emit("return ");
    expr(); // Emit expression
    emit(";\n");
    
    beg char* ret_type = expr_type;
    expect("SEMICOL");
    
    if current_fn_ret_type != ret_type {
        boo("Error: Incompatible " + ret_type + " to " + current_fn_ret_type + " conversion on line " + itos(line_num));
        return -1;
    }
    return 0;
}


// =============================================================
// Expression Parsers
// =============================================================

ah int expr() {
    // Main entry point for parsing an expression.
    // Emits C code. Sets global 'expr_type'.
    return logical();
}

ah int logical() {
    // Handles: expr (&& | ||) expr
    relational(); // Emits left side
    beg char* left_type = expr_type;

    while peek() == "OR" || peek() == "AND" {
        beg int op_idx = next();
        beg char* op = op_to_c_op(token_types[op_idx]);

        emit(" "); emit(op); emit(" ");

        relational(); // Emits right side
        beg char* right_type = expr_type;

        // Type check: logical ops must be on ints (or chars)
        if left_type != "int" || right_type != "int" {
            boo("Error: Logical operators '&&' and '||' can only be used on integers, line " + itos(token_lines[op_idx]));
            return -1;
        }
        
        expr_type = "int"; // Result is always an int
        left_type = "int";
    }

    expr_type = left_type; // Set final type
    return 0;
}

ah int relational() {
    // Handles: expr (== | != | < | > | <= | >=) expr

    // 1. Peek LHS (using additive parser)
    beg char* left_ptr = peek_code("additive");
    beg char* left_type = expr_type;

    // Need local copy because peek_code buffer will be overwritten
    beg char left_buf[2048];
    beg int i = 0;
    while left_ptr[i] != '\0' {
        left_buf[i] = left_ptr[i];
        i = i + 1;
    }
    left_buf[i] = '\0';

    if peek() == "EQ" || peek() == "NE" ||
       peek() == "LT" || peek() == "GT" ||
       peek() == "LE" || peek() == "GE" {

        while peek() == "EQ" || peek() == "NE" ||
              peek() == "LT" || peek() == "GT" ||
              peek() == "LE" || peek() == "GE" {

            beg int op_idx = next();
            beg char* op = op_to_c_op(token_types[op_idx]);
            beg int line = token_lines[op_idx];

            // 2. Peek RHS
            beg char* rhs_code = peek_code("additive");
            beg char* rhs_type = expr_type;

            // 3. Generate Code
            if (left_type == "char*" && rhs_type == "char*") {
                if (op == "==") {
                    emit("strcmp("); emit(left_buf); emit(", "); emit(rhs_code); emit(") == 0");
                } else if (op == "!=") {
                    emit("strcmp("); emit(left_buf); emit(", "); emit(rhs_code); emit(") != 0");
                } else {
                    boo("Error: Operator '" + op + "' not allowed on strings, line " + itos(line));
                    return -1;
                }
            } else if (left_type == "char*" || rhs_type == "char*") {
                 boo("Error: Comparison between string and non-string, line " + itos(line));
                 return -1;
            } else {
                // Standard int/char
                emit(left_buf); emit(" "); emit(op); emit(" "); emit(rhs_code);
            }
            
            expr_type = "int";
            left_type = "int";
        }
    } else {
        // No operators, just emit LHS
        emit(left_buf);
        expr_type = left_type; // Restore type
    }

    return 0;
}

ah int additive() {
    // Handles: expr (+ | -) expr
    // This also handles pointer arithmetic.

    // 1. Peek LHS (using multiplicative parser)
    beg char* left_ptr = peek_code("multiplicative");
    beg char* left_type = expr_type;

    // Need local copy because peek_code buffer will be overwritten
    beg char left_buf[2048];
    beg int i = 0;
    while (left_ptr[i] != '\0') {
        left_buf[i] = left_ptr[i];
        i = i + 1;
    }
    left_buf[i] = '\0';

    if peek() == "PLUS" || peek() == "MINUS" {
        while peek() == "PLUS" || peek() == "MINUS" {
            beg int op_idx = next();
            beg char* op = op_to_c_op(token_types[op_idx]);
            beg int line = token_lines[op_idx];

            // 2. Peek RHS
            beg char* right_code = peek_code("multiplicative");
            beg char* right_type = expr_type;

            // 3. Generate Code
            // Case 1: int + int
            if left_type == "int" && right_type == "int" {
                emit(left_buf); emit(" "); emit(op); emit(" "); emit(right_code);
                expr_type = "int";
            }

            // Case 2: Pointer Arithmetic
            else if str_ends_with(left_type, '*') && right_type == "int" {
                emit(left_buf); emit(" "); emit(op); emit(" "); emit(right_code);
                expr_type = left_type; // e.g., int* + int = int*
            }
            else if left_type == "int" && str_ends_with(right_type, '*') {
                if op == "+" {
                    emit(left_buf); emit(op); emit(right_code);
                    expr_type = right_type; // int + int* = int*
                } else {
                    boo("Error: Cannot subtract a pointer from an integer, line " + itos(line));
                    return -1;
                }
            }

            // Case 3: String Concat (char* + char*)
            else if left_type == "char*" && right_type == "char*" && op == "+" {
                emit("concat("); emit(left_buf); emit(", "); emit(right_code); emit(")");
                expr_type = "char*";
            }

            // Case 4: Error
            else {
                boo("Error: Operator '" + op + "' not allowed between '" + left_type + "' and '" + right_type + "', line " + itos(line));
                return -1;
            }
            left_type = expr_type;
        }
    } else {
        // No operators, just emit LHS
        emit(left_buf);
        expr_type = left_type; // Restore type
    }
    expr_type = left_type;
    return 0;
}

ah int multiplicative() {
    // Handles: expr (* | /) expr
    unary();
    beg char* left_type = expr_type;

    while peek() == "MUL" || peek() == "DIV" {
        beg int op_idx = next();
        beg char* op = op_to_c_op(token_types[op_idx]);
        
        emit(" "); emit(op); emit(" ");

        unary();
        beg char* right_type = expr_type;

        if left_type != "int" || right_type != "int" {
            boo("Error: Operators '*' and '/' can only be used on integers, line " + itos(token_lines[op_idx]));
            return -1;
        }
        
        expr_type = "int";
        left_type = "int";
    }
    
    expr_type = left_type;
    return 0;
}

ah int unary() {
    // Handles: -expr
    if peek() == "MINUS" {
        beg int op_idx = next();
        emit("-");
        
        unary(); // Recursive call
        
        if expr_type != "int" {
            boo("Error: Unary '-' operator can only be applied to integers, line " + itos(token_lines[op_idx]));
            return -1;
        }
        
        expr_type = "int";
        return 0;
    }
    
    return atom();
}

ah int atom() {
    // Handles: literals, variables, (expr), fn_call(), arr[idx]
    // This is the first function to set the global 'expr_type'.

    beg int tok_idx = next();
    beg char* tok_type = token_types[tok_idx];
    beg int tok_val_idx = token_values[tok_idx];
    beg int tok_line = token_lines[tok_idx];
    
    // Case 1: Literals
    if tok_type == "NUMBER" {
        expr_type = "int";
        emit(token_pool + tok_val_idx);
    }
    else if tok_type == "CHAR" {
        expr_type = "char";
        emit(token_pool + tok_val_idx);
    }
    else if tok_type == "STRING" {
        expr_type = "char*";
        emit("\""); emit(token_pool + tok_val_idx); emit("\"");
    }
    
    // Case 2: Parenthesized Expression
    else if tok_type == "LPAREN" {
        emit("(");
        expr();
        emit(")");
        expect("RPAREN");
    }

    // Case 3: Identifier (var, array index, function call)
    else if tok_type == "ID" {
        beg char* var_name = token_pool + tok_val_idx;
        
        // Look for symbol in local, then global scope
        beg char* sym_type = get_symbol_type(0, var_name);
        
        if sym_type == "" {
            boo("Error: Undeclared identifier '" + var_name + "' on line " + itos(tok_line));
            return -1;
        }
        
        // Sub-case 3a: Function Call - ID()
        if peek() == "LPAREN" {
            next();
            expr_type = sym_type; // Type is the function's return type
            emit(var_name);
            emit("(");
            
            beg int arg_count = 0;
            while peek() != "RPAREN" {
                if arg_count > 0 {
                    expect("COMMA");
                    emit(", ");
                }
                expr();
                arg_count = arg_count + 1;
            }
            expect("RPAREN");
            emit(")");
        }
        // Sub-case 3b: Array Access - ID[]
        else if peek() == "LSQUARE" {
            if str_ends_with(sym_type, '*') == 0 {
                boo("Error: Variable '" + var_name + "' is not an array and cannot be indexed, line " + itos(tok_line));
                return -1;
            }
            next();
            emit(var_name);
            emit("[");
            
            expr();
            if expr_type != "int" {
                boo("Error: Array index must be an integer, line " + itos(tok_line));
                return -1;
            }
            expect("RSQUARE");
            emit("]");
            
            // Set type to the base type (e.g., "int*" -> "int")
            // TODO: We need a string function for this.
            // For now, we assume simple types.
            if sym_type == "int*" { expr_type = "int"; }
            else if sym_type == "char*" { expr_type = "char"; }
            else { expr_type = "int"; } // Default assumption
        }
        // Sub-case 3c: Simple Variable
        else {
            expr_type = sym_type;
            emit(var_name);
        }
    }
    
    // Case 4: Error
    else {
        boo("Error: Unexpected token in expression: " + tok_type + " on line " + itos(tok_line));
        return -1;
    }
    return 0;
}


// =============================================================
// Parser Helpers
// =============================================================

ah char* peek() {
    // Returns the type of the current token.
    return token_types[parser_pos];
}

ah int next() {
    // Consumes the current token and returns its index.
    beg int current_pos = parser_pos;
    parser_pos = parser_pos + 1;
    return current_pos;
}

ah int expect(char* kind) {
    // Checks if the current token is of the expected 'kind'.
    // If yes, consumes it and returns its index.
    // If no, prints an error and returns -1.
    
    // Skips comments and gets type
    beg char* tok_type = peek();
    
    if tok_type == kind {
        // Consume and return index
        return next();
    }
    
    // Handle error
    beg int tok_line = token_lines[parser_pos];
    boo("Error: Syntax Error on line " + itos(tok_line));
    boo("Expected token: " + kind);
    boo("... but got token: " + tok_type);
    
    // In a real compiler, we'd exit here.
    return -1; // Indicate error
}


// =============================================================
// Symbol Table Helpers
// =============================================================

ah int clear_local_symbols() {
    // Clears the local (function-level) symbol table.
    // Called when entering a new function.
    n_locals = 0;
    return 0;
}

ah char* get_symbol_type(int is_global, char* name) {
    // Searches for a variable 'name' in the given 'scope'.
    // Returns its type (e.g., "int", "char*") if found.
    // Returns "" (empty string) if not found.
    
    beg int i = 0;
    
    if is_global == 0 {
        while i < n_locals {
            if local_names[i] == name {
                return local_types[i];
            }
            i = i + 1;
        }
    } else { // "global"
        while i < n_globals {
            if global_names[i] == name {
                return global_types[i];
            }
            i = i + 1;
        }
    }
    
    // Not found, check outer scope (if local)
    if is_global == 0 {
        return get_symbol_type(1, name);
    }
    
    return ""; // Not found anywhere
}

ah int add_symbol(int is_global, char* name, char* type) {
    // Adds a new variable to the symbol table.
    // Returns 0 on success.
    // NOTE: This function assumes you have already checked for redefinition.
    if is_global == 0 {
        local_names[n_locals] = name;
        local_types[n_locals] = type;
        n_locals = n_locals + 1;
    } else {
        global_names[n_globals] = name;
        global_types[n_globals] = type;
        n_globals = n_globals + 1;
    }
    return 0;
}


// =============================================================
// Parser Utils
// =============================================================

ah int str_ends_with(char* s, char c) {
    // Checks if string 's' ends with character 'c'.
    // Returns 1 (true) or 0 (false).
    beg int len = strlen(s);
    if len == 0 {
        return 0; // Empty string
    }
    
    if s[len - 1] == c {
        return 1;
    }
    return 0;
}

ah char* op_to_c_op(char* tok_type) {
    // Translates a token type (e.g., "PLUS") to its C operator (e.g., "+").
    if tok_type == "PLUS" { return "+"; }
    if tok_type == "MINUS" { return "-"; }
    if tok_type == "MUL" { return "*"; }
    if tok_type == "DIV" { return "/"; }
    if tok_type == "EQ" { return "=="; }
    if tok_type == "NE" { return "!="; }
    if tok_type == "LT" { return "<"; }
    if tok_type == "GT" { return ">"; }
    if tok_type == "LE" { return "<="; }
    if tok_type == "GE" { return ">="; }
    if tok_type == "AND" { return "&&"; }
    if tok_type == "OR" { return "||"; }
    
    // Should never happen, but good to have a default.
    return ""; 
}

ah int emit(char* s) {
    // Appends a string 's' to the global c_code_buffer.
    beg int i = 0;
    beg int len = strlen(s);

    // --- Bounds check ---
    if (c_code_pos + len >= 1000000) {
        boo("CRITICAL ERROR: C code output buffer overflow! Increase c_code_buffer size.");
        return -1; // This will likely cascade errors, but it prints the warning.
    }

    while i < len {
        c_code_buffer[c_code_pos] = s[i];
        c_code_pos = c_code_pos + 1;
        i = i + 1;
    }
    c_code_buffer[c_code_pos] = '\0'; // Keep buffer null-terminated
    return 0;
}

ah char* peek_code(char* level) {
    beg int start_pos = c_code_pos;
    
    if (level == "expr") { expr(); }
    else if (level == "logical") { logical(); }
    else if (level == "relational") { relational(); }
    else if (level == "additive") { additive(); }
    else if (level == "multiplicative") { multiplicative(); }
    else if (level == "unary") { unary(); }
    else if (level == "atom") { atom(); }
    else {
        boo("Error: Unknown peek level: " + level);
        return "";
    }
    
    beg int end_pos = c_code_pos;
    beg int len = end_pos - start_pos;
    
    if (len >= 4096) {
        boo("Error: Expression too complex to peek (max 4096 chars).");
        return "";
    }
    
    beg int i = 0;
    while (i < len) {
        expr_peek_buffer[i] = c_code_buffer[start_pos + i];
        i = i + 1;
    }
    expr_peek_buffer[i] = '\0';
    
    // Rewind
    c_code_pos = start_pos;
    
    return expr_peek_buffer;
}

ah int c_include() {
    // Emit C include
    emit("#include <stdio.h>\n");
    emit("#include <stdlib.h>\n");
    emit("#include <string.h>\n\n");
    return 0;
}

ah int c_prototype() {
    // Emit C prototype
    emit("char* concat(char* str1, char* str2);\n");
    emit("char* itos(int x);\n");
    emit("char* ctos(char c);\n\n");
    emit("char* read_file(char* path);\n");
    emit("void write_file(char* path, char* content);\n");
    return 0;
}

ah int c_helper() {
    // Emit C helper
    emit("\nchar* concat(char* str1, char* str2) {\n");
    emit("static char buf[1024];\n");
    emit("snprintf(buf, sizeof(buf), \"%s%s\", str1, str2);\n");
    emit("return buf;\n}\n\n");

    emit("char* itos(int x) {\n");
    emit("static char buf[32];\n");
    emit("snprintf(buf, sizeof(buf), \"%d\", x);\n");
    emit("return buf;\n}\n\n");

    emit("char* ctos(char c) {\n");
    emit("static char buf[2];\n");
    emit("buf[0] = c;\n");
    emit("buf[1] = '\\0';\n");
    emit("return buf;\n}\n\n");

    emit("char* read_file(char* path) {\n");
    emit("FILE* f = fopen(path, \"rb\");\n");
    emit("if (!f) return NULL;\n");
    emit("fseek(f, 0, SEEK_END);\n");
    emit("long len = ftell(f);\n");
    emit("fseek(f, 0, SEEK_SET);\n");
    emit("char* buf = malloc(len + 1);\n");
    emit("fread(buf, 1, len, f);\n");
    emit("buf[len] = '\\0';\n");
    emit("fclose(f);\n");
    emit("return buf;\n}\n\n");

    emit("void write_file(char* path, char* content) {\n");
    emit("FILE* f = fopen(path, \"w\");\n");
    emit("if (!f) return;\n");
    emit("fprintf(f, \"%s\", content);\n");
    emit("fclose(f);\n}\n");
    return 0;
}

ah int preset_global_functions() {
    // Preset global scope with util functions
    add_symbol(1, "concat", "char*");
    add_symbol(1, "ctos", "char*");
    add_symbol(1, "itos", "char*");
    add_symbol(1, "strlen", "int");
    add_symbol(1, "strcmp", "int");
    add_symbol(1, "read_file", "char*");
    add_symbol(1, "write_file", "void");
    return 0;
}


// =============================================================
// Tokenizer
//
// This is the main lexer logic, ported from python/lexer/lexer.py
// =============================================================

ah int tokenize(char* source_code) {
    beg int pos = 0;
    beg int line_num = 1;
    beg int line_start = 0;
    
    beg char buffer[100];
    beg int i = 0;
 
    beg int token_count = 0;
    beg int pool_pos = 0;

    beg char c;
    beg int col;
    beg int j;
    beg char token_val;
    beg int token_start_col;
    
    while source_code[pos] != '\0' {
        c = source_code[pos];
        col = pos - line_start;
        i = 0;

        // --- Bounds check ---
        if (token_count >= 50000) {
             boo("CRITICAL ERROR: Too many tokens! Increase token array sizes.");
             return 0;
        }
        if (pool_pos >= 499000) { // Leave some safety margin
             boo("CRITICAL ERROR: String pool overflow! Increase token_pool size.");
             return 0;
        }

        // --- 1. Skip Whitespace ---
        if is_space(c) {
            if c == '\n' {
                line_num = line_num + 1;
                line_start = pos + 1;
            }
            pos = pos + 1;
        } 
        
        // --- 2. Check for Numbers ---
        else if is_digit(c) {
            token_start_col = col;
            while is_digit(c) {
                buffer[i] = c; i = i + 1; pos = pos + 1; c = source_code[pos];
            }
            if c == '.' {
                buffer[i] = c; i = i + 1; pos = pos + 1; c = source_code[pos];
                while is_digit(c) {
                    buffer[i] = c; i = i + 1; pos = pos + 1; c = source_code[pos];
                }
            }
            buffer[i] = '\0';
            
            token_types[token_count] = "NUMBER";
            token_lines[token_count] = line_num;
            token_cols[token_count] = token_start_col;
            
            // Copy buffer to string pool
            token_values[token_count] = pool_pos;
            j = 0;

            // <= to include the '\0'
            while j <= i {
                token_pool[pool_pos] = buffer[j];
                pool_pos = pool_pos + 1;
                j = j + 1;
            }
            token_count = token_count + 1;
        }
        
        // --- 3. Check for Identifiers & Keywords ---
        else if is_letter(c) {
            token_start_col = col;
            while is_ident_char(c) {
                buffer[i] = c; i = i + 1; pos = pos + 1; c = source_code[pos];
            }
            buffer[i] = '\0';

            beg char* tok_type = check_keywords(buffer);
            token_types[token_count] = tok_type;
            token_lines[token_count] = line_num;
            token_cols[token_count] = token_start_col;

            // Copy buffer to string pool
            if tok_type != "ID" && tok_type != "TYPE" {
                token_values[token_count] = -1;
            } else {
                token_values[token_count] = pool_pos;
                j = 0;
                while j <= i {
                    token_pool[pool_pos] = buffer[j];
                    pool_pos = pool_pos + 1;
                    j = j + 1;
                }
            }
            token_count = token_count + 1;
        }

        // --- 4. Check for Multi-Char Tokens ---
        else if c == '=' {
            if source_code[pos + 1] == '=' {
                add_simple_token(token_count, "EQ", line_num, col);
                token_count = token_count + 1; pos = pos + 2;
            } else {
                add_simple_token(token_count, "ASSIGN", line_num, col);
                token_count = token_count + 1; pos = pos + 1;
            }
        }
        else if c == '!' && source_code[pos + 1] == '=' {
            add_simple_token(token_count, "NE", line_num, col);
            token_count = token_count + 1; pos = pos + 2;
        }
        else if c == '>' {
            if source_code[pos + 1] == '=' {
                add_simple_token(token_count, "GE", line_num, col);
                token_count = token_count + 1; pos = pos + 2;
            } else {
                add_simple_token(token_count, "GT", line_num, col);
                token_count = token_count + 1; pos = pos + 1;
            }
        }
        else if c == '<' {
            if source_code[pos + 1] == '=' {
                add_simple_token(token_count, "LE", line_num, col);
                token_count = token_count + 1; pos = pos + 2;
            } else {
                add_simple_token(token_count, "LT", line_num, col);
                token_count = token_count + 1; pos = pos + 1;
            }
        }
        else if c == '&' && source_code[pos + 1] == '&' {
            add_simple_token(token_count, "AND", line_num, col);
            token_count = token_count + 1; pos = pos + 2;
        }
        else if c == '|' && source_code[pos + 1] == '|' {
            add_simple_token(token_count, "OR", line_num, col);
            token_count = token_count + 1; pos = pos + 2;
        }
        else if c == '/' {
            if source_code[pos + 1] == '/' {
                // TODO: Maybe add comments
                // add_simple_token(token_count, "COMMENT", line_num, col);
                // token_count = token_count + 1; pos = pos + 2;
 
                // Loop to skip till after newline or EOL
                while source_code[pos] != '\n' && source_code[pos] != '\n' {
                    pos = pos + 1;
                }
            } else {
                add_simple_token(token_count, "DIV", line_num, col);
                token_count = token_count + 1; pos = pos + 1;
            }
        }

        // --- 5. Check for Single-Char Tokens ---
        else if c == '(' {
            add_simple_token(token_count, "LPAREN", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }
        else if c == ')' {
            add_simple_token(token_count, "RPAREN", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }
        else if c == '{' {
            add_simple_token(token_count, "LBRACE", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }
        else if c == '}' {
            add_simple_token(token_count, "RBRACE", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }
        else if c == '[' {
            add_simple_token(token_count, "LSQUARE", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }
        else if c == ']' {
            add_simple_token(token_count, "RSQUARE", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }
        else if c == '+' {
            add_simple_token(token_count, "PLUS", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }
        else if c == '-' {
            add_simple_token(token_count, "MINUS", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }
        else if c == '*' {
            add_simple_token(token_count, "MUL", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }
        else if c == ';' {
            add_simple_token(token_count, "SEMICOL", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }
        else if c == ',' {
            add_simple_token(token_count, "COMMA", line_num, col);
            token_count = token_count + 1; pos = pos + 1;
        }

        // --- 6. Handle Strings and Chars ---
        else if c == '"' {
            token_start_col = col;
            pos = pos + 1; c = source_code[pos];

            while c != '"' && c != '\0' {
                if c == '\\' {
                    pos = pos + 1; c = source_code[pos];
                    
                    if c == 'n' { buffer[i] = '\n';
                    } else if c == 't' { buffer[i] = '\t';
                    } else if c == '"' { buffer[i] = '"';
                    } else if c == '\\' { buffer[i] = '\\';
                    } else { buffer[i] = c; }
                }
                else { buffer[i] = c; }
                i = i + 1; pos = pos + 1; c = source_code[pos];
            }
            
            // Check unclosed string
            if c == '\0' { boo("Error: Unclosed string literal!"); return 1; }
            pos = pos + 1;
            buffer[i] = '\0';

            // Add token
            token_types[token_count] = "STRING";
            token_lines[token_count] = line_num;
            token_cols[token_count] = token_start_col;
            token_values[token_count] = pool_pos;
            j = 0;
            while (j <= i) {
                token_pool[pool_pos] = buffer[j];
                pool_pos = pool_pos + 1;
                j = j + 1;
            }
            token_count = token_count + 1;
        }
        else if c == '\'' {
            token_start_col = col;
            pos = pos + 1; c = source_code[pos];
            token_val = c;

            if c == '\\' {
                pos = pos + 1; c = source_code[pos];

                if c == 'n' { token_val = '\n';
                } else if c == 't' { token_val = '\t';
                } else if c == '\'' { token_val = '\'';
                } else if c == '\\' { token_val = '\\';
                } else { token_val = c; }
            }

            pos = pos + 1; c = source_code[pos];
            if c != '\'' { boo("Error: Unclosed or invalid char literal!"); return 1; }
            pos = pos + 1;
            
            // Add token
            buffer[0] = token_val; buffer[1] = '\0';
            token_types[token_count] = "CHAR";
            token_lines[token_count] = line_num;
            token_cols[token_count] = token_start_col;
            token_values[token_count] = pool_pos;
            token_pool[pool_pos] = buffer[0];
            token_pool[pool_pos + 1] = buffer[1];
            pool_pos = pool_pos + 2;
            token_count = token_count + 1;
        }

        // --- 7. Handle Errors ---
        else {
            boo("Error: Unexpected character!");
            boo(ctos(c));
            return 1;
        }
    }
    
    // Add EOF Token
    add_simple_token(token_count, "EOF", line_num, col);
    token_count = token_count + 1;

    return token_count;
}

// =============================================================
// Lexer Helpers
//
// We port the logic from the Python lexer.
// =============================================================

ah int is_letter(char c) {
    // Checks if a character is a letter or underscore.
    // Corresponds to: [A-Za-z_]
    return (c >= 'a' && c <= 'z') || 
           (c >= 'A' && c <= 'Z') || 
           (c == '_');
}

ah int is_digit(char c) {
    // Checks if a character is a 0-9 digit.
    // Corresponds to: \d
    return (c >= '0' && c <= '9');
}

ah int is_space(char c) {
    // Checks for whitespace characters to skip.
    // Corresponds to: [ \t\n]
    return (c == ' ') || (c == '\t') || (c == '\n');
}

ah int is_ident_char(char c) {
    // Checks if a char can be part of an identifier *after* the first char.
    // Corresponds to: [A-Za-z0-9_]
    return is_letter(c) || is_digit(c);
}

ah char* check_keywords(char* s) {
    // Checks if a string 's' is a keyword.
    // If it is, return the keyword's Token Type.
    // Otherwise, return "ID".
    if s == "ah" {
        return "FN";
    } else if s == "beg" {
        return "LET";
    } else if s == "boo" {
        return "PRINT";
    } else if s == "if" {
        return "IF";
    } else if s == "else" {
        return "ELSE";
    } else if s == "while" {
        return "WHILE";
    } else if s == "return" {
        return "RETURN";
    } else if s == "int*" || s == "char*" ||
              s == "int" || s == "char" ||
              s == "void"  {
        return "TYPE";
    }

    // Default case: not a keyword
    return "ID";
}

ah int add_simple_token(int index, char* type, int line, int col) {
    // Helper to add a simple token (without a value) to the token arrays.
    token_types[index] = type;
    token_values[index] = -1; // -1 means no value
    token_lines[index] = line;
    token_cols[index] = col;
    return 0;
}
